def I fn a a .

alias return I .
alias identity I .
alias id I .

def S fn (a b c)
  a c : b c .

def K fn (a b)
  a .

alias KI false .

def compose fn (a b c)
  a : b c .

alias B compose .
alias uni compose .
alias ∘ compose .
alias o compose .
alias comp compose .

def C fn (a b c)
  a c b .

alias swap C .

def flip fn f
  fn (x y)
    x y : f y x .

def D fn (a b c d)
  a b : c d .

def F fn (a b c)
  c b a .

def H fn (a b c)
  a b c b .

def J fn (a b c d)
  a b : a d c .

def L fn (a b)
  a : b b .

def N fn (a b c d)
  a (b d) (c d) .

alias bi N .

def O fn (a b)
  b : a b .

;; Named with quote because T is a special symbol in Lisp.
def T fn (a b)
  b a .

def W fn (a b)
  a b b .

alias dup W .
alias duplicate W .

def ω fn a
  a a .

;; TODO Ω

def Y fn g
  local inner = fn (x) g x x .
  inner inner .

def Z fn f
  local inner = fn (x) f (fn y : x x y) .
  inner inner .

def Z2 fn f
  local inner = (fn (x) f (fn (y z) x x y z)) .
  inner inner .

;; TODO Θ

def ι fn f
  f S K .

def agenda fn (p f g)
  fn x
    if : p x
     then f x
     else g x .

def piping fn (init cont)
  cont init .

def pipe fn (f cont val)
  cont : f val .

def pipe2 fn (f arg cont val)
  cont : f arg val .

def pipe3 fn (f arg1 arg2 cont val)
  cont : f arg1 arg2 val .

alias piped identity .

alias --> piping .
alias -> pipe .
alias -2> pipe2 .
alias -3> pipe3 .
alias >-- piped .

alias threading piping .
alias thread pipe .
alias thread2 pipe2 .
alias thread3 pipe3 .
alias threaded piped .

;; Yes, it’s ugly and unlikely to be used by anyone.
;; Still, a fun experiment.
;; writes : itos : --> 3 : -> (* 2) : -> 1+ >-- .